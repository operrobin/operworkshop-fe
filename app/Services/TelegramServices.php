<?php

namespace App\Services;

use GuzzleHttp\Client;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7;
use Log;

/** 
 * TelegramServices
 * A service to control telegram bot via Telegram API
 * 
 * @link https://core.telegram.org/bots/api
 */

class TelegramServices{

    const TELEGRAM_CHAT_CHARACTERS_LIMIT = 2000;

    private function telegramCallback($method, $uri, $params = [], $multipart = false){
        $client = new Client();
        $options = [];
        $uri = env('TELEGRAM_API_URI').env('TELEGRAM_API_KEY').$uri;

        # If params not empty, prepare the method
        if(!empty($params))
            switch($method){
                case "GET": 
                    $options["headers"] = [
                        'Content-Type' => 'application/json',
                        'Accept' => 'application/json'
                    ];

                    $options["query"] = $params; 
                    break;

                default: 
                    if($multipart){
                        $multipart_params = [];

                        foreach($params as $key => $set){
                            if(!empty($set)){
                                if(is_object($set)){
                                    /**
                                     * @see https://www.php.net/manual/en/class.splfileinfo.php
                                     * 
                                     * Currently multipart only supports for file that directly generated by PHP it self.
                                     */
                                    $multipart_params[] = [
                                        'filename' => "File Report Log ".date('Y-m-d H:i:s', strtotime('now')).".xlsx",
                                        'name' => $key,
                                        'contents' => file_get_contents($set->getPathName())
                                    ];

                                }else{
                                    $multipart_params[] = [
                                        "name" => $key,
                                        "contents" => $set
                                    ];
                                }
                            }
                        }

                        $options["multipart"] = $multipart_params;
                    }else{
                        $options["headers"] = [
                            'Content-Type' => 'application/json',
                            'Accept' => 'application/json'
                        ];

                        $options["json"] = $params;
                    }
            }

        try{
            $response = $client->request(
                strtoupper($method),
                $uri,
                $options
            );


            $jsonObj = json_decode($response->getBody()->getContents());

            return new BaseResponse(
                true,
                200,
                $jsonObj->message ?? null,
                $jsonObj->result ?? $jsonObj
            );
        }catch(RequestException $e){
            $response = $e->getResponse();

            // Logging error
            Log::alert('REQUEST_INFO: \n\n URI: '.$uri.'\n\n Body: '.json_encode($params));
            Log::alert('ERROR_REQUEST: '.Psr7\str($e->getRequest()));
            Log::alert('ERROR_RESPONSE: '.json_encode($e->getResponse()));
            Log::alert('ERROR: '. json_encode($e->getMessage()));

            if(method_exists($response, 'getBody')){
                $jsonObj = json_decode((string) $response->getBody()); //To catch getBody() on null case

                return new BaseResponse($jsonObj->status ?? false,$jsonObj->code ?? null,$jsonObj->message ?? null , $jsonObj->data ?? null);
            }

            return new BaseResponse(
                false,
                $e->getResponse()->getStatusCode(),
                $e->getResponse()->getReasonPhrase(),
                null
            );
        }
    }

    /**
     * sendMessage
     * A service to send message to client
     * 
     * @param message (string) (mandatory)
     * 
     * @return BaseResponse => mixed json
     */
    public function sendMessage($message){
        
        /**
         * Limiting Telegram characters to 2000
         */
        if(strlen($message) >= self::TELEGRAM_CHAT_CHARACTERS_LIMIT){
            $message = substr(
                        $message, 
                        0, 
                        self::TELEGRAM_CHAT_CHARACTERS_LIMIT - 3).". . . . . Message length exceed ".self::TELEGRAM_CHAT_CHARACTERS_LIMIT." characters. Please check log file.";
        }

        return $this->telegramCallback(
            "POST", 
            "/sendMessage", 
            [
                "chat_id" => env('TELEGRAM_CHAT_ID'),
                "text" => $message
            ],
            true
        );
    }
}

final class BaseResponse
{
    public $status;
    public $code;
    public $message;
    public $data;

    public function __construct($status,$code,$message = "",$data = [])
    {
        $this->status = $status;
        $this->code = $code;
        $this->message = $message;
        $this->data = $data;
    }
} 